// -*- mode: objc -*-

// bindings for https://github.com/sdegutis/Windows

var mash = ["CMD", "ALT", "CTRL"];

// mash-R reloads this config for testing
[Keys bind:"R" modifiers:mash fn: function() {
    [App reloadConfig];
}];

// maximize
[Keys bind:"M" modifiers:mash fn: function() {
    var win = [Win focusedWindow];
    var frame = [[win screen] frameInWindowCoordinates];
    [win setFrame: frame];
}];

// snap this window to grid
[Keys bind:"." modifiers:mash fn: function() {
    var win = [Win focusedWindow];
    var r = gridProps(win);
    moveToGridProps(win, r);
}];

// snap all windows to grid
[Keys bind:"," modifiers:mash fn: function() {
    _.each([Win visibleWindows], function(win) {
        var r = gridProps(win);
        moveToGridProps(win, r);
    });
}];

// move left
[Keys bind:"H" modifiers:mash fn: function() {
    var win = [Win focusedWindow];
    var r = gridProps(win);
    r.origin.x = Math.max(r.origin.x - 1, 0);
    moveToGridProps(win, r);
}];

// move right
[Keys bind:"L" modifiers:mash fn: function() {
    var win = [Win focusedWindow];
    var r = gridProps(win);
    r.origin.x = Math.min(r.origin.x + 1, 3 - r.size.width);
    moveToGridProps(win, r);
}];

// grow to right
[Keys bind:"O" modifiers:mash fn: function() {
    var win = [Win focusedWindow];
    var r = gridProps(win);
    r.size.width = Math.min(r.size.width + 1, 3 - r.origin.x);
    moveToGridProps(win, r);
}];

// shrink from right
[Keys bind:"I" modifiers:mash fn: function() {
    var win = [Win focusedWindow];
    var r = gridProps(win);
    r.size.width = Math.max(r.size.width - 1, 1);
    moveToGridProps(win, r);
}];

// move to upper row
[Keys bind:"K" modifiers:mash fn: function() {
    var win = [Win focusedWindow];
    var r = gridProps(win);
    r.origin.y = 0;
    r.size.height = 1;
    moveToGridProps(win, r);
}];

// move to lower row
[Keys bind:"J" modifiers:mash fn: function() {
    var win = [Win focusedWindow];
    var r = gridProps(win);
    r.origin.y = 1;
    r.size.height = 1;
    moveToGridProps(win, r);
}];

// fill whole vertical column
[Keys bind:"U" modifiers:mash fn: function() {
    var win = [Win focusedWindow];
    var r = gridProps(win);
    r.origin.y = 0;
    r.size.height = 2;
    moveToGridProps(win, r);
}];


// mash-[12]: prev/next screen
[Keys bind:"1" modifiers:mash fn: function() {
    var win = [Win focusedWindow];

    var screens = [NSScreen screens];
    var currentScreen = [win screen];

    var idx = [screens indexOfObject:currentScreen];

    idx += 1;
    if (idx == [screens count])
        idx = 0;

    var nextScreen = screens[idx];

    moveToGridPropsOnScreen(win, nextScreen, gridProps(win));
}];

[Keys bind:"2" modifiers:mash fn: function() {
    var win = [Win focusedWindow];

    var screens = [NSScreen screens];
    var currentScreen = [win screen];

    var idx = [screens indexOfObject:currentScreen];

    idx -= 1;
    if (idx == -1)
        idx = [screens count] - 1;

    var nextScreen = screens[idx];

    moveToGridPropsOnScreen(win, nextScreen, gridProps(win));
}];

// next/prev win, sorta kinda working
[Keys bind:"p" modifiers:mash fn: function() {
    var win = nextWindow(-1);
    if (win) [win focusWindow];
}];

[Keys bind:"n" modifiers:mash fn: function() {
    var win = nextWindow(1);
    if (win) [win focusWindow];
}];

// helper functions

var nextWindow = function(n) {
  var current = Win.focusedWindow;
  var windows = current.otherWindowsOnSameScreen;
  var pos     = [windows indexOfObject:current];

  if (pos === -1) return; // possible?

  if (n === -1) {
    return windows[pos - 1] || windows[windows.length - 1];
  } else if (n === 1) {
    return windows[pos + 1] || windows[0];
  }
};

var gridProps = function(win) {
    var winFrame = [win frame];
    var screenRect = [[win screen] frameInWindowCoordinates];

    var thirdScrenWidth = screenRect.size.width / 3.0;
    var halfScreenHeight = screenRect.size.height / 2.0;

    return CGRectMake(Math.round((winFrame.origin.x - NSMinX(screenRect)) / thirdScrenWidth),
                      Math.round((winFrame.origin.y - NSMinY(screenRect)) / halfScreenHeight),
                      Math.max(Math.round(winFrame.size.width / thirdScrenWidth), 1),
                      Math.max(Math.round(winFrame.size.height / halfScreenHeight), 1));
};

var moveToGridProps = function(win, gridProps) {
  moveToGridPropsOnScreen(win, [win screen], gridProps);
};

var moveToGridPropsOnScreen = function(win, screen, gridProps) {
    var screenRect = [screen frameInWindowCoordinates];

    var thirdScrenWidth = screenRect.size.width / 3.0;
    var halfScreenHeight = screenRect.size.height / 2.0;

    var newFrame = CGRectMake((gridProps.origin.x * thirdScrenWidth) + NSMinX(screenRect),
                              (gridProps.origin.y * halfScreenHeight) + NSMinY(screenRect),
                              gridProps.size.width * thirdScrenWidth,
                              gridProps.size.height * halfScreenHeight);

    newFrame = NSInsetRect(newFrame, 5, 5); // acts as a little margin between windows, to give shadows some breathing room
    newFrame = NSIntegralRect(newFrame);

    [win setFrame: newFrame];
};
